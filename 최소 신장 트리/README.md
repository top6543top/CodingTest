# 정의

- 신장 트리

  방향성이 없는 그래프의 부분 그래프에서 모든 정점을 포함하는 트리

- 최소 신장 트리

  신장 트리 중에서 간선의 합이 최소인 신장 트리

# 구하는 법

   - 크루스칼 알고리즘

    Union-Find 알고리즘을 알아야 해결가능

    ---
    * Union-find 알고리즘이란?

    Disjoint-Set(서로소)를 찾아가는 알고리즘

    union(x,y) -> x가 속한 집합과 y가 속한 집합을 합치는 함수

    find(parent,x) -> x가 속한 그룹 찾기(부모찾기) x가 속한 루트 노드를 반환


      public static boolean union(int x, int y) {
          	x = find(x); //x의 부모노드 찾기
          	y = find(y); //y의 부모노드 찾기
              
          	// 이미 같은 그래프에 속해있을 때 false 반환
          	if(x == y) return false;
          	
          	if(x <= y) parent[y] = x;
          	else parent[x] = y;
          	return true;
      }
      public static int find(int x) {
        	if(parent[x] == x) return x;
        	return find(parent[x]);
      }
 
    ---

    가장 비용이 낮은 간선부터 시작하여 간선을 크기 순으로 살펴보며 서로 떨어져있던 정점들을 합쳐나가서 v-1개의 간선을 택하는 알고리즘

    1) 간선을 크기의 오름차순으로 정렬하고 제일 낮은비용의 간선을 선택
    2) 현재 선택한 간선이 정점 u,v를 연결하는 간선이라고 할 때, 만약 u,v가 같은 그룹이라면 아무것도 하지 않고 넘어감, 다른 그룹이라면 같은 그룹으로 만들고
       현재 선택한 간선을 최소 신장트리에 추가
    3) 최소 신장 트리에 V-1개의 간선을 추가 시켰다면 과정을 종료 , 그렇지 않다면 그다음으로 비용이 작은 간선을 선택하여 2번 과정 반복


   - 프림 알고리즘

      우선순위 큐를 가지고 구현
    
    1) 임의의 정점을 선택해 최소 신장트리에 추가  
    
    -> 구현 방식 : 해당 정점과 연결된 모든 간선을 우선순위 큐에 추가 
    
    2) 최소 신장 트리에 포함된 정점과 최소 신장 트리에 포함되지 않은 정점을 연결하는 간선 중 비용이 가장 작은 것을 최소 신장 트리에 추가 
    
    -> 구현 방식 : 우선 순위 큐에서 비용이 가장 작은 간선을 선택, 해당 간선이 최소 신장트리에 포함되지 않는 두 정점을 연결한다면 아무것도 하지않고 넘어감

    해당 간선이 최소 신장 트리에 포함된 u와 포함되지 않은 v를 연결한다면 해당 간선과 정점 v를 최소 신장 트리에 추가후 정점 v와 최소 신장트리에 포함되지 않는 정점을 연결하는 간선을 우선순위 큐에 추가
    
    3) 최소 신장 트리에 v-1개의 간선이 추가 될 때 까지 2번 과정 반복

    https://velog.io/@suk13574/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Java-%ED%94%84%EB%A6%BCPrim-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

    다음 사이트 참고
       
