## 골드 5 파이프 옮기기


### - 문제 유형
 
  다이나믹 프로그래밍, 그래프 탐색

### - 문제 해결 방법

  1. 첫번째 풀이 방법은 BFS로 접근하였다.
 
     가로,세로,대각선으로 놓여있을때 움직이는 방향이 각각 다르므로 조건문을 이용하여 종점을 찾아가도록 구현하였다.

     But, 시간 초과가 발생 -> visited가 없는 BFS는 브루트포스 알고리즘을 BFS형태로 구현해 놓은 거라서

     중복되는 정점을 계속 반복하면서 시간 복잡도가 높아진다고 한다. BFS는 최단거리를 찾을때는 유용하다. 

     So, 질문을 참고하여 마지막 점이 1인 경우만 예외처리하는 방법을 이용하여 해결 하였다.

     근본적인 해결방법은 DFS를 이용하는 것이다.
     
  2. 두번째 방법은 DP로 해결하는 것이다.

     dp를 이용하면 훨씬 빠른 속도로 구현을 할 수 있다.

     이전 점의 값을 더해주는 방식으로 dp를 이용하는데

     ex) i,j인 점까지 갈 수 있는 경우를 찾아보면

     i-1,j에서 세로로 가는 방법  /  i,j-1에서 가로로 가는 방법  /  i-1, j-1에서 대각선가는 방법이 있다.

     세로로 움직이려면 i-1,j에서 파이프는 세로 or 대각선이어야 하고

     가로로 움직이려면 i,j-1에서 파이프는 가로 or 대각선이어야 한다.

     대각선으로 움직이려면 i-1,j-1에서 파이프는 대각선 or 세로 or 가로 이어야 한다.

     조건을 충족하는 값을 더해서 i,j에서 파이프가 대각선, 세로, 가로 일때를 배열에 저장해 나아가면서 dp로 해결하면 가능하다.

     

### - 알게 된 점

       BFS가 거리 찾기에서 최적인 줄 알았는데 visited 가 없으면 똑같은 점을 더욱 자주 방문하는 브루스포스 알고리즘과 유사하다는 것을 알게 되었다

       이런 경우 DFS를 사용해야 된다는 점을 알게 되었다.

       dp로 풀이한 코드를 보면
       
       ```java
                if(i==1){
                    dp[1][i][j]=0;
                } else {
                    dp[1][i][j]=dp[1][i-1][j]+dp[2][i-1][j];
                }
       ```
       

       이런식으로 i==1일때 와 같이 예외처리를 해줬는데 첫째 줄은 가로로만 이동이 가능하므로 벽이 없는한 값 1을 주면 예외처리 없이 더 간결한 코드를 작성 할 수 있었다.
