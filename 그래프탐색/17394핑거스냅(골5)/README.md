## 골드 5 17394 핑거스냅

- 문제 유형

  그래프 이론, 에라토스테네스의 채(소수 판정)

- 문제 풀이 방법

  먼저 나의 풀이는 배열을 이용하여 arr[] 배열에 에라토스테네스의 채를 이용하여 A<=B의 범위이므로

  B까지의 소수를 구했다. 이후 bfs를 이용해 queue에 시작 수인 n을 넣고 n이 갈 수 있는 숫자를 cnt를 늘려가며 저장을 하고

  마지막에 A,B사이의 범위에서 소수가 있는지 확인하여 그 사이의 cnt 중 가장 작은 수를 구하는 방식으로 진행을 하였다.

  내 풀이의 문제점은 queue에 cnt까지 같이 넣어 저장하면 가장 빠른 cnt부터 저장되므로 queue에서 나온 수가 A,B 사이의 소수이면

  그 소수를 반환하면 되는데, 반복문을 돌려 굳이 최소 값을 확인했다는 점이다.

- 개념 설명

  1. 소수구하기

      일반적인 소수 구하는 알고리즘은 O(N)의 복잡도이다.
    
      ```java
        // N이 소수인지를 구한다고 하면
        for(int i=2;i<n;i++){
          // 2~N까지 나눠지는 숫자가 있다고 하면 소수가 아니므로 false 반환
          if(N%i==0) return false;    
        }
      ```
    
      N개의 숫자를 소수를 구한다고 하면 시간복잡도는 O(N^2)이 된다.
    
      따라서 많은 숫자를 구하기가 힘들다.
    
      따라서 에라토스테네스의 채를 이용한다.
     
  3. 에라토스테네스의 채

      0,1은 소수가 아니므로 지운다. 지워지지 않은 숫자의 배수를 구하려는 N까지 지우면된다.

     ex) 2의배수 4,6,8 ... -> 그다음 지워지지 않은 숫자는 3이므로 3을 제외한 6,9,12 ... 이런식으로 루트 N까지 진행해주면된다.

     따라서 식은

     ```java
       for(int i=2;i<=Math.sqrt(N);i++){
         // sqrt(N)까지 하는 이유는 N=a*b의 형식으로 갈텐데 a,b는 무조건 루트 N보다 작을 것이기 때문이다.
         // i가 소수이면
           if(isPrime[i]){
               // 그뒤의 배수는 소수가 아니다.
              for(int j=i*2;j<=N;j+=i){
                  isPrime[j]=false;
               }
           }
       }
     ```

     이런 식으로 구현하면 시간 복잡도는 O(nloglogN) 이 되어 더욱 간단해 질 수 있다.

  
