 ## 실버 1 동물원(다시 풀어봐야 함)

 https://www.acmicpc.net/problem/1309

 - 문제 유형

    다이나믹 프로그래밍

- 문제 해결 방식

  다이나믹 프로그래밍은 점화식을 구하는 방법이 중요하다.

  내가 구현했던 첫 점화식은 dp[i][j]=dp[i][j-2]+dp[(i+1)%2][j-1]+dp[(i+1)%2][j-2] 이었다.

  이 점화식을 생각했던 이유는 그 칸이 1이 될 경우의 수를 전의 칸이 어떤 상태여야 가능한가를 생각하는 점화식이였고

  전의 칸은 점화식에서 나온 3칸만을 고려했다. 그 이유는 dp이기때문에 다른 경우의 수는 다 그 전 점화식에 들어있다고 생각했었다.

  사실, 이 생각은 틀린게 전 칸을 모두 고려해야 그 칸이 1이 되는 경우를 모두 계산해야 했기때문에

  O(n^2)으로 n<=100_000인 이 문제에서는 해결할 수 없는 방식이였다.

  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - - - -  - - - - - -

  따라서 한 줄의 상태를 dp배열로 만들어 해결하는 방식이 해결방법이였다.

```java
  //사자가 두칸다 없으려면 전에 어떤 것이든 상관없다
			dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD;
            // 1번째 칸에 사자가 있으려면 1칸에만 사자가 없으면 된다.
			dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD;
            // 2번째 칸에 사자가 있으려면 2칸에만 사자가 없으면 된다.
			dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
```

  둘다 없음 , 1번칸에 있음 , 2번칸에 있음을 각각 dp배열로만들어 그 줄의 상태를 dp배열로 넘기는 방법이 문제 해결방식이였다.

  그 전의 상태가 다 저장되어서 넘어오므로 결과는 마지막 n번째 줄의 0,1,2 배열을 더해주면 되는 문제 였다.
